'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _commander = require('commander');

var _package = require('../../package.json');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _gherkin = require('gherkin');

var _gherkin2 = _interopRequireDefault(_gherkin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ArgvParser = function () {
  function ArgvParser() {
    (0, _classCallCheck3.default)(this, ArgvParser);
  }

  (0, _createClass3.default)(ArgvParser, null, [{
    key: 'collect',
    value: function collect(val, memo) {
      memo.push(val);
      return memo;
    }
  }, {
    key: 'mergeJson',
    value: function mergeJson(option) {
      return function (str, memo) {
        var val = void 0;
        try {
          val = JSON.parse(str);
        } catch (error) {
          throw new Error(option + ' passed invalid JSON: ' + error.message + ': ' + str);
        }
        if (!_lodash2.default.isPlainObject(val)) {
          throw new Error(option + ' must be passed JSON of an object: ' + str);
        }
        return _lodash2.default.merge(memo, val);
      };
    }
  }, {
    key: 'mergeTags',
    value: function mergeTags(val, memo) {
      return memo === '' ? '(' + val + ')' : memo + ' and (' + val + ')';
    }
  }, {
    key: 'validateLanguage',
    value: function validateLanguage(val) {
      if (!_lodash2.default.includes(_lodash2.default.keys(_gherkin2.default.DIALECTS), val)) {
        throw new Error('Unsupported ISO 639-1: ' + val);
      }
      return val;
    }
  }, {
    key: 'parse',
    value: function parse(argv) {
      var program = new _commander.Command(_path2.default.basename(argv[1]));

      program.usage('[options] [<GLOB|DIR|FILE[:LINE]>...]').version(_package.version, '-v, --version').option('-b, --backtrace', 'show full backtrace for errors').option('-d, --dry-run', 'invoke formatters without executing steps').option('--exit', 'force shutdown of the event loop when the test run has finished: cucumber will call process.exit').option('--fail-fast', 'abort the run on first failure').option('-f, --format <TYPE[:PATH]>', 'specify the output format, optionally supply PATH to redirect formatter output (repeatable)', ArgvParser.collect, []).option('--format-options <JSON>', 'provide options for formatters (repeatable)', ArgvParser.mergeJson('--format-options'), {}).option('--i18n-keywords <ISO 639-1>', 'list language keywords', ArgvParser.validateLanguage, '').option('--i18n-languages', 'list languages').option('--language <ISO 639-1>', 'provide the default language for feature files', '').option('--name <REGEXP>', 'only execute the scenarios with name matching the expression (repeatable)', ArgvParser.collect, []).option('--no-strict', 'succeed even if there are pending steps').option('-p, --profile <NAME>', 'specify the profile to use (repeatable)', ArgvParser.collect, []).option('--parallel <NUMBER_OF_SLAVES>', 'run in parallel with the given number of slaves', parseInt, 0).option('-r, --require <GLOB|DIR|FILE>', 'require files before executing features (repeatable)', ArgvParser.collect, []).option('--require-module <NODE_MODULE>', 'require node modules before requiring files (repeatable)', ArgvParser.collect, []).option('-t, --tags <EXPRESSION>', 'only execute the features or scenarios with tags matching the expression (repeatable)', ArgvParser.mergeTags, '').option('--world-parameters <JSON>', 'provide parameters that will be passed to the world constructor (repeatable)', ArgvParser.mergeJson('--world-parameters'), {});

      program.on('--help', function () {
        /* eslint-disable no-console */
        console.log('  For more details please visit https://github.com/cucumber/cucumber-js#cli\n');
        /* eslint-enable no-console */
      });

      program.parse(argv);

      return {
        options: program.opts(),
        args: program.args
      };
    }
  }]);
  return ArgvParser;
}();

exports.default = ArgvParser;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGkvYXJndl9wYXJzZXIuanMiXSwibmFtZXMiOlsiQXJndlBhcnNlciIsInZhbCIsIm1lbW8iLCJwdXNoIiwib3B0aW9uIiwic3RyIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJpc1BsYWluT2JqZWN0IiwibWVyZ2UiLCJpbmNsdWRlcyIsImtleXMiLCJESUFMRUNUUyIsImFyZ3YiLCJwcm9ncmFtIiwiYmFzZW5hbWUiLCJ1c2FnZSIsInZlcnNpb24iLCJjb2xsZWN0IiwibWVyZ2VKc29uIiwidmFsaWRhdGVMYW5ndWFnZSIsInBhcnNlSW50IiwibWVyZ2VUYWdzIiwib24iLCJjb25zb2xlIiwibG9nIiwib3B0aW9ucyIsIm9wdHMiLCJhcmdzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0lBRXFCQSxVOzs7Ozs7OzRCQUNKQyxHLEVBQUtDLEksRUFBTTtBQUN4QkEsV0FBS0MsSUFBTCxDQUFVRixHQUFWO0FBQ0EsYUFBT0MsSUFBUDtBQUNEOzs7OEJBRWdCRSxNLEVBQVE7QUFDdkIsYUFBTyxVQUFTQyxHQUFULEVBQWNILElBQWQsRUFBb0I7QUFDekIsWUFBSUQsWUFBSjtBQUNBLFlBQUk7QUFDRkEsZ0JBQU1LLEtBQUtDLEtBQUwsQ0FBV0YsR0FBWCxDQUFOO0FBQ0QsU0FGRCxDQUVFLE9BQU9HLEtBQVAsRUFBYztBQUNkLGdCQUFNLElBQUlDLEtBQUosQ0FDSkwsU0FBUyx3QkFBVCxHQUFvQ0ksTUFBTUUsT0FBMUMsR0FBb0QsSUFBcEQsR0FBMkRMLEdBRHZELENBQU47QUFHRDtBQUNELFlBQUksQ0FBQyxpQkFBRU0sYUFBRixDQUFnQlYsR0FBaEIsQ0FBTCxFQUEyQjtBQUN6QixnQkFBTSxJQUFJUSxLQUFKLENBQVVMLFNBQVMscUNBQVQsR0FBaURDLEdBQTNELENBQU47QUFDRDtBQUNELGVBQU8saUJBQUVPLEtBQUYsQ0FBUVYsSUFBUixFQUFjRCxHQUFkLENBQVA7QUFDRCxPQWJEO0FBY0Q7Ozs4QkFFZ0JBLEcsRUFBS0MsSSxFQUFNO0FBQzFCLGFBQU9BLFNBQVMsRUFBVCxTQUFrQkQsR0FBbEIsU0FBOEJDLElBQTlCLGNBQTJDRCxHQUEzQyxNQUFQO0FBQ0Q7OztxQ0FFdUJBLEcsRUFBSztBQUMzQixVQUFJLENBQUMsaUJBQUVZLFFBQUYsQ0FBVyxpQkFBRUMsSUFBRixDQUFPLGtCQUFRQyxRQUFmLENBQVgsRUFBcUNkLEdBQXJDLENBQUwsRUFBZ0Q7QUFDOUMsY0FBTSxJQUFJUSxLQUFKLENBQVUsNEJBQTRCUixHQUF0QyxDQUFOO0FBQ0Q7QUFDRCxhQUFPQSxHQUFQO0FBQ0Q7OzswQkFFWWUsSSxFQUFNO0FBQ2pCLFVBQU1DLFVBQVUsdUJBQVksZUFBS0MsUUFBTCxDQUFjRixLQUFLLENBQUwsQ0FBZCxDQUFaLENBQWhCOztBQUVBQyxjQUNHRSxLQURILENBQ1MsdUNBRFQsRUFFR0MsT0FGSCxtQkFFb0IsZUFGcEIsRUFHR2hCLE1BSEgsQ0FHVSxpQkFIVixFQUc2QixnQ0FIN0IsRUFJR0EsTUFKSCxDQUlVLGVBSlYsRUFJMkIsMkNBSjNCLEVBS0dBLE1BTEgsQ0FNSSxRQU5KLEVBT0ksa0dBUEosRUFTR0EsTUFUSCxDQVNVLGFBVFYsRUFTeUIsZ0NBVHpCLEVBVUdBLE1BVkgsQ0FXSSw0QkFYSixFQVlJLDZGQVpKLEVBYUlKLFdBQVdxQixPQWJmLEVBY0ksRUFkSixFQWdCR2pCLE1BaEJILENBaUJJLHlCQWpCSixFQWtCSSw2Q0FsQkosRUFtQklKLFdBQVdzQixTQUFYLENBQXFCLGtCQUFyQixDQW5CSixFQW9CSSxFQXBCSixFQXNCR2xCLE1BdEJILENBdUJJLDZCQXZCSixFQXdCSSx3QkF4QkosRUF5QklKLFdBQVd1QixnQkF6QmYsRUEwQkksRUExQkosRUE0QkduQixNQTVCSCxDQTRCVSxrQkE1QlYsRUE0QjhCLGdCQTVCOUIsRUE2QkdBLE1BN0JILENBOEJJLHdCQTlCSixFQStCSSxnREEvQkosRUFnQ0ksRUFoQ0osRUFrQ0dBLE1BbENILENBbUNJLGlCQW5DSixFQW9DSSwyRUFwQ0osRUFxQ0lKLFdBQVdxQixPQXJDZixFQXNDSSxFQXRDSixFQXdDR2pCLE1BeENILENBd0NVLGFBeENWLEVBd0N5Qix5Q0F4Q3pCLEVBeUNHQSxNQXpDSCxDQTBDSSxzQkExQ0osRUEyQ0kseUNBM0NKLEVBNENJSixXQUFXcUIsT0E1Q2YsRUE2Q0ksRUE3Q0osRUErQ0dqQixNQS9DSCxDQWdESSwrQkFoREosRUFpREksaURBakRKLEVBa0RJb0IsUUFsREosRUFtREksQ0FuREosRUFxREdwQixNQXJESCxDQXNESSwrQkF0REosRUF1REksc0RBdkRKLEVBd0RJSixXQUFXcUIsT0F4RGYsRUF5REksRUF6REosRUEyREdqQixNQTNESCxDQTRESSxnQ0E1REosRUE2REksMERBN0RKLEVBOERJSixXQUFXcUIsT0E5RGYsRUErREksRUEvREosRUFpRUdqQixNQWpFSCxDQWtFSSx5QkFsRUosRUFtRUksdUZBbkVKLEVBb0VJSixXQUFXeUIsU0FwRWYsRUFxRUksRUFyRUosRUF1RUdyQixNQXZFSCxDQXdFSSwyQkF4RUosRUF5RUksOEVBekVKLEVBMEVJSixXQUFXc0IsU0FBWCxDQUFxQixvQkFBckIsQ0ExRUosRUEyRUksRUEzRUo7O0FBOEVBTCxjQUFRUyxFQUFSLENBQVcsUUFBWCxFQUFxQixZQUFNO0FBQ3pCO0FBQ0FDLGdCQUFRQyxHQUFSLENBQ0UsK0VBREY7QUFHQTtBQUNELE9BTkQ7O0FBUUFYLGNBQVFWLEtBQVIsQ0FBY1MsSUFBZDs7QUFFQSxhQUFPO0FBQ0xhLGlCQUFTWixRQUFRYSxJQUFSLEVBREo7QUFFTEMsY0FBTWQsUUFBUWM7QUFGVCxPQUFQO0FBSUQ7Ozs7O2tCQWpJa0IvQixVIiwiZmlsZSI6ImFyZ3ZfcGFyc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJ2NvbW1hbmRlcidcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IEdoZXJraW4gZnJvbSAnZ2hlcmtpbidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJndlBhcnNlciB7XG4gIHN0YXRpYyBjb2xsZWN0KHZhbCwgbWVtbykge1xuICAgIG1lbW8ucHVzaCh2YWwpXG4gICAgcmV0dXJuIG1lbW9cbiAgfVxuXG4gIHN0YXRpYyBtZXJnZUpzb24ob3B0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgbWVtbykge1xuICAgICAgbGV0IHZhbFxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsID0gSlNPTi5wYXJzZShzdHIpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgb3B0aW9uICsgJyBwYXNzZWQgaW52YWxpZCBKU09OOiAnICsgZXJyb3IubWVzc2FnZSArICc6ICcgKyBzdHJcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFfLmlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3B0aW9uICsgJyBtdXN0IGJlIHBhc3NlZCBKU09OIG9mIGFuIG9iamVjdDogJyArIHN0cilcbiAgICAgIH1cbiAgICAgIHJldHVybiBfLm1lcmdlKG1lbW8sIHZhbClcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgbWVyZ2VUYWdzKHZhbCwgbWVtbykge1xuICAgIHJldHVybiBtZW1vID09PSAnJyA/IGAoJHt2YWx9KWAgOiBgJHttZW1vfSBhbmQgKCR7dmFsfSlgXG4gIH1cblxuICBzdGF0aWMgdmFsaWRhdGVMYW5ndWFnZSh2YWwpIHtcbiAgICBpZiAoIV8uaW5jbHVkZXMoXy5rZXlzKEdoZXJraW4uRElBTEVDVFMpLCB2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIElTTyA2MzktMTogJyArIHZhbClcbiAgICB9XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgc3RhdGljIHBhcnNlKGFyZ3YpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IENvbW1hbmQocGF0aC5iYXNlbmFtZShhcmd2WzFdKSlcblxuICAgIHByb2dyYW1cbiAgICAgIC51c2FnZSgnW29wdGlvbnNdIFs8R0xPQnxESVJ8RklMRVs6TElORV0+Li4uXScpXG4gICAgICAudmVyc2lvbih2ZXJzaW9uLCAnLXYsIC0tdmVyc2lvbicpXG4gICAgICAub3B0aW9uKCctYiwgLS1iYWNrdHJhY2UnLCAnc2hvdyBmdWxsIGJhY2t0cmFjZSBmb3IgZXJyb3JzJylcbiAgICAgIC5vcHRpb24oJy1kLCAtLWRyeS1ydW4nLCAnaW52b2tlIGZvcm1hdHRlcnMgd2l0aG91dCBleGVjdXRpbmcgc3RlcHMnKVxuICAgICAgLm9wdGlvbihcbiAgICAgICAgJy0tZXhpdCcsXG4gICAgICAgICdmb3JjZSBzaHV0ZG93biBvZiB0aGUgZXZlbnQgbG9vcCB3aGVuIHRoZSB0ZXN0IHJ1biBoYXMgZmluaXNoZWQ6IGN1Y3VtYmVyIHdpbGwgY2FsbCBwcm9jZXNzLmV4aXQnXG4gICAgICApXG4gICAgICAub3B0aW9uKCctLWZhaWwtZmFzdCcsICdhYm9ydCB0aGUgcnVuIG9uIGZpcnN0IGZhaWx1cmUnKVxuICAgICAgLm9wdGlvbihcbiAgICAgICAgJy1mLCAtLWZvcm1hdCA8VFlQRVs6UEFUSF0+JyxcbiAgICAgICAgJ3NwZWNpZnkgdGhlIG91dHB1dCBmb3JtYXQsIG9wdGlvbmFsbHkgc3VwcGx5IFBBVEggdG8gcmVkaXJlY3QgZm9ybWF0dGVyIG91dHB1dCAocmVwZWF0YWJsZSknLFxuICAgICAgICBBcmd2UGFyc2VyLmNvbGxlY3QsXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgICAub3B0aW9uKFxuICAgICAgICAnLS1mb3JtYXQtb3B0aW9ucyA8SlNPTj4nLFxuICAgICAgICAncHJvdmlkZSBvcHRpb25zIGZvciBmb3JtYXR0ZXJzIChyZXBlYXRhYmxlKScsXG4gICAgICAgIEFyZ3ZQYXJzZXIubWVyZ2VKc29uKCctLWZvcm1hdC1vcHRpb25zJyksXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgICAub3B0aW9uKFxuICAgICAgICAnLS1pMThuLWtleXdvcmRzIDxJU08gNjM5LTE+JyxcbiAgICAgICAgJ2xpc3QgbGFuZ3VhZ2Uga2V5d29yZHMnLFxuICAgICAgICBBcmd2UGFyc2VyLnZhbGlkYXRlTGFuZ3VhZ2UsXG4gICAgICAgICcnXG4gICAgICApXG4gICAgICAub3B0aW9uKCctLWkxOG4tbGFuZ3VhZ2VzJywgJ2xpc3QgbGFuZ3VhZ2VzJylcbiAgICAgIC5vcHRpb24oXG4gICAgICAgICctLWxhbmd1YWdlIDxJU08gNjM5LTE+JyxcbiAgICAgICAgJ3Byb3ZpZGUgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UgZm9yIGZlYXR1cmUgZmlsZXMnLFxuICAgICAgICAnJ1xuICAgICAgKVxuICAgICAgLm9wdGlvbihcbiAgICAgICAgJy0tbmFtZSA8UkVHRVhQPicsXG4gICAgICAgICdvbmx5IGV4ZWN1dGUgdGhlIHNjZW5hcmlvcyB3aXRoIG5hbWUgbWF0Y2hpbmcgdGhlIGV4cHJlc3Npb24gKHJlcGVhdGFibGUpJyxcbiAgICAgICAgQXJndlBhcnNlci5jb2xsZWN0LFxuICAgICAgICBbXVxuICAgICAgKVxuICAgICAgLm9wdGlvbignLS1uby1zdHJpY3QnLCAnc3VjY2VlZCBldmVuIGlmIHRoZXJlIGFyZSBwZW5kaW5nIHN0ZXBzJylcbiAgICAgIC5vcHRpb24oXG4gICAgICAgICctcCwgLS1wcm9maWxlIDxOQU1FPicsXG4gICAgICAgICdzcGVjaWZ5IHRoZSBwcm9maWxlIHRvIHVzZSAocmVwZWF0YWJsZSknLFxuICAgICAgICBBcmd2UGFyc2VyLmNvbGxlY3QsXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgICAub3B0aW9uKFxuICAgICAgICAnLS1wYXJhbGxlbCA8TlVNQkVSX09GX1NMQVZFUz4nLFxuICAgICAgICAncnVuIGluIHBhcmFsbGVsIHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiBzbGF2ZXMnLFxuICAgICAgICBwYXJzZUludCxcbiAgICAgICAgMFxuICAgICAgKVxuICAgICAgLm9wdGlvbihcbiAgICAgICAgJy1yLCAtLXJlcXVpcmUgPEdMT0J8RElSfEZJTEU+JyxcbiAgICAgICAgJ3JlcXVpcmUgZmlsZXMgYmVmb3JlIGV4ZWN1dGluZyBmZWF0dXJlcyAocmVwZWF0YWJsZSknLFxuICAgICAgICBBcmd2UGFyc2VyLmNvbGxlY3QsXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgICAub3B0aW9uKFxuICAgICAgICAnLS1yZXF1aXJlLW1vZHVsZSA8Tk9ERV9NT0RVTEU+JyxcbiAgICAgICAgJ3JlcXVpcmUgbm9kZSBtb2R1bGVzIGJlZm9yZSByZXF1aXJpbmcgZmlsZXMgKHJlcGVhdGFibGUpJyxcbiAgICAgICAgQXJndlBhcnNlci5jb2xsZWN0LFxuICAgICAgICBbXVxuICAgICAgKVxuICAgICAgLm9wdGlvbihcbiAgICAgICAgJy10LCAtLXRhZ3MgPEVYUFJFU1NJT04+JyxcbiAgICAgICAgJ29ubHkgZXhlY3V0ZSB0aGUgZmVhdHVyZXMgb3Igc2NlbmFyaW9zIHdpdGggdGFncyBtYXRjaGluZyB0aGUgZXhwcmVzc2lvbiAocmVwZWF0YWJsZSknLFxuICAgICAgICBBcmd2UGFyc2VyLm1lcmdlVGFncyxcbiAgICAgICAgJydcbiAgICAgIClcbiAgICAgIC5vcHRpb24oXG4gICAgICAgICctLXdvcmxkLXBhcmFtZXRlcnMgPEpTT04+JyxcbiAgICAgICAgJ3Byb3ZpZGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3b3JsZCBjb25zdHJ1Y3RvciAocmVwZWF0YWJsZSknLFxuICAgICAgICBBcmd2UGFyc2VyLm1lcmdlSnNvbignLS13b3JsZC1wYXJhbWV0ZXJzJyksXG4gICAgICAgIHt9XG4gICAgICApXG5cbiAgICBwcm9ncmFtLm9uKCctLWhlbHAnLCAoKSA9PiB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgJyAgRm9yIG1vcmUgZGV0YWlscyBwbGVhc2UgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL2N1Y3VtYmVyL2N1Y3VtYmVyLWpzI2NsaVxcbidcbiAgICAgIClcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgIH0pXG5cbiAgICBwcm9ncmFtLnBhcnNlKGFyZ3YpXG5cbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczogcHJvZ3JhbS5vcHRzKCksXG4gICAgICBhcmdzOiBwcm9ncmFtLmFyZ3NcbiAgICB9XG4gIH1cbn1cbiJdfQ==